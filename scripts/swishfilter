#!/usr/bin/python
# ... | swish-e -S prog -i stdin -c etc/swish.config 

import os
import email.Parser, email.Message
import getopt
import sys
import string
import time
import rfc822
import tempfile
import subprocess

swishconfig_template = """
DefaultContents XML*
IndexFile %s.index
MetaNames subject from to cc bcc list-id message-id date
PropertyNamesDate date
"""

parser = email.Parser.Parser()

class LockError(RuntimeError): pass

class Lock:
    def __init__(self, path, delay=.1, max_delay=30):
        self.path = None
        while 1:
            try:
                fd = os.open(path, os.O_WRONLY | os.O_CREAT | os.O_EXCL)
                break
            except os.error, detail:
                if detail.errno != errno.EEXIST: raise
            if delay > max_delay: raise LockError, "Did not lock after %f seconds" % max_delay
            time.sleep(delay)
            delay = delay * 2
        self.path = path
        os.close(fd)

    def __del__(self):
        if self.path is not None:
            os.unlink(self.path)
            self.path = None

def write_one(path, data):
    sys.stdout.write("Path-name: %s\nContent-Length: %d\n\n" %(path, len(data)))
    sys.stdout.write(data)

null = string.maketrans("", "")
remove = "".join(chr(c) for c in range(32))

def escape(s):
    s = s.translate(null, remove)
    s = s.replace("&", "&amp;");
    s = s.replace("<", "&lt;");
    s = s.replace(">", "&gt;");
    return s

def recode(payload, encoding):
    payload = payload.replace("", "")
    if isinstance(payload, unicode):
        return payload.encode("utf-8")
    encoding = encoding or "ascii"
    encoding = encoding.replace(" ", "")
    try:
        payload = payload.decode(encoding)
    except (UnicodeDecodeError, LookupError):
        try:
            payload = payload.decode("utf-8")
        except UnicodeDecodeError:
            payload = payload.decode("latin-1")
    return payload.encode("utf-8")
 
def get_payload(m):
    payload = m.get_payload()
    encoding = m.get_content_charset()
    if payload is None:
        print >>sys.stderr, "Payload is None in", m, repr(m._payload)[:20]
        return ''
    if isinstance(payload, basestring):
        if m.get_content_maintype() not in ("text", None): return ""
        payload = m.get_payload(decode=True) or payload
        payload = recode(payload, encoding)
        return escape(payload)
    result = []
    for p in payload:
        if not isinstance(p, email.Message.Message):
            print >>sys.stderr, "Unexpected payload item", p.__class__.__name__
            continue
        result.append("<attachment>")
        result.append(get_payload(p))
        result.append("</attachment>")
    return "".join(result)

def parse_date(s):
    try:
        return str(int(rfc822.mktime_tz(rfc822.parsedate_tz(s))))
    except:
        print >>sys.stderr, "parse_date failed:", repr(s)[:50]
        return str(0)

date_fields = set(['date'])

def do_one(start, filename, key):
    if start is not None:
        if os.stat(filename).st_mtime < start: return
    m = parser.parse(open(filename))
    result = ['<?xml version="1.0" encoding="UTF-8"?><message><headers>']
    for h in m.keys():
        h = h.lower()
        for v in m.get_all(h):
            if h in date_fields: v = parse_date(v)
            result.append('<%s>%s</%s>\n' % (h, escape(v), h))
    result.append('</headers><body>')
    result.append(get_payload(m))
    result.append('</body></message>')
    write_one(key, "".join(result))

def usage(result=0):
    print """mailpie-filter: Produce input for swish-e
Usage: %s [-b dir] [file ...]
        -B dir: The root directory of the mailpie storage  Default: ~/.mailpie
        -t time: Do not index files earlier than this time Default: all files
""" % os.path.basename(sys.argv[0])
    raise SystemExit, result

def main(args):
    try:
        opts, args = getopt.getopt(args, "B:s:ih?",
            ["--help", "--since=", "incremental="])
    except getopt.GetoptError, detail:
        usage(detail)

    base = os.path.expanduser("~/.mailpie")
    start = None
    use_last = False

    for k, v in opts:
        if k in ("-?", "-h", "--help"): usage()
        if k in ("-B", "--base"): base = v
        if k in ("-s", "--since"): start = float(v)
        if k in ("-i", "--incremental"): use_last = time.time()

    if start is not None and use_last:
        usage("Error: --since and --incremental are mutually exclusive")

    lock = Lock(base + ".lock")

    if use_last:
        lastfile = base + ".last"
        if os.path.exists(lastfile):
            start = float(open(lastfile).read())

    index = base + ".index"
    swishconfig = tempfile.NamedTemporaryFile()
    swishconfig.write(swishconfig_template % index)
    swishconfig.flush()

    swish_args = ['swish-e', '-S', 'prog', '-i', 'stdin',
            '-c', swishconfig.name]

    if use_last:
            swish_args.extend(['-f', index + ".incremental"])

    swish = subprocess.Popen(swish_args, stdin=subprocess.PIPE)
    sys.stdout = swish.stdin
    os.chdir(base)
    dirs = ['%02x' % i for i in range(255)]
    for dir in dirs:
        print >>sys.stderr, "%5.1f complete" % (int(dir, 16) * 100. / 256)
        if not os.path.exists(dir): continue
        os.chdir(dir)
        for file in os.listdir(os.path.curdir):
            do_one(start, file, dir+file)
        os.chdir(os.path.pardir)
    swish.stdin.close()
    result = swish.wait()
    if result != 0:
        raise SystemExit, "swish-e exited with code %d" % result
    if use_last:
        if os.path.exists(index):
            os.spawnvp(os.P_WAIT, 'swish-e', ['swish-e', '-M', index, index + ".incremental", index + ".merge"])
            print >>sys.stderr, "done already?"
            os.rename(index + ".merge", index)
            os.rename(index + ".merge.prop", index + ".prop")
            os.unlink(index + ".incremental")
            os.unlink(index + ".incremental.prop")
        else:
            os.rename(index + ".incremental", index)
            os.rename(index + ".incremental.prop", index + ".prop")
        open(lastfile, "w").write("%s" % use_last) 

if __name__ == '__main__':
    main(sys.argv[1:])
